-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParProgettoPar
  ( happyError
  , myLexer
  , pS
  ) where

import Prelude

import qualified AbsProgettoPar
import LexProgettoPar

}

%name pS S
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '%=' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '(' { PT _ (TS _ 7) }
  ')' { PT _ (TS _ 8) }
  '*' { PT _ (TS _ 9) }
  '**' { PT _ (TS _ 10) }
  '**=' { PT _ (TS _ 11) }
  '*=' { PT _ (TS _ 12) }
  '+' { PT _ (TS _ 13) }
  '+=' { PT _ (TS _ 14) }
  ',' { PT _ (TS _ 15) }
  '-' { PT _ (TS _ 16) }
  '-=' { PT _ (TS _ 17) }
  '..' { PT _ (TS _ 18) }
  '/' { PT _ (TS _ 19) }
  '/=' { PT _ (TS _ 20) }
  ':' { PT _ (TS _ 21) }
  ';' { PT _ (TS _ 22) }
  '<' { PT _ (TS _ 23) }
  '<=' { PT _ (TS _ 24) }
  '=' { PT _ (TS _ 25) }
  '==' { PT _ (TS _ 26) }
  '>' { PT _ (TS _ 27) }
  '>=' { PT _ (TS _ 28) }
  'False' { PT _ (TS _ 29) }
  'True' { PT _ (TS _ 30) }
  '[' { PT _ (TS _ 31) }
  ']' { PT _ (TS _ 32) }
  'bool' { PT _ (TS _ 33) }
  'break' { PT _ (TS _ 34) }
  'char' { PT _ (TS _ 35) }
  'const' { PT _ (TS _ 36) }
  'continue' { PT _ (TS _ 37) }
  'do' { PT _ (TS _ 38) }
  'else' { PT _ (TS _ 39) }
  'false' { PT _ (TS _ 40) }
  'for' { PT _ (TS _ 41) }
  'forall' { PT _ (TS _ 42) }
  'function' { PT _ (TS _ 43) }
  'if' { PT _ (TS _ 44) }
  'in' { PT _ (TS _ 45) }
  'int' { PT _ (TS _ 46) }
  'param' { PT _ (TS _ 47) }
  'proc' { PT _ (TS _ 48) }
  'real' { PT _ (TS _ 49) }
  'ref' { PT _ (TS _ 50) }
  'return' { PT _ (TS _ 51) }
  'string' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'var' { PT _ (TS _ 55) }
  'void' { PT _ (TS _ 56) }
  'while' { PT _ (TS _ 57) }
  '{' { PT _ (TS _ 58) }
  '||' { PT _ (TS _ 59) }
  '}' { PT _ (TS _ 60) }
  L_Ident  { PT _ (TV _) }
  L_charac { PT _ (TC _) }
  L_doubl  { PT _ (TD _) }
  L_integ  { PT _ (TI _) }
  L_quoted { PT _ (TL _) }

%%

Ident :: { AbsProgettoPar.Ident Posn }
Ident  : L_Ident { AbsProgettoPar.Ident (getTokenContent $1) (tokenPosn $1) }

Char    :: { AbsProgettoPar.Char Posn }
Char     : L_charac { AbsProgettoPar.Char ((read (getTokenContent $1)) :: Prelude.Char  ) (tokenPosn $1) }

Double  :: { AbsProgettoPar.Real Posn }
Double   : L_doubl  { AbsProgettoPar.Real ((read (getTokenContent $1)) :: Prelude.Double  ) (tokenPosn $1) }

Integer :: { AbsProgettoPar.Integer Posn }
Integer  : L_integ  { AbsProgettoPar.Integer ((read (getTokenContent $1)) :: Prelude.Integer ) (tokenPosn $1) }

String  :: { AbsProgettoPar.String  Posn }
String   : L_quoted { AbsProgettoPar.String (getTokenContent $1) (tokenPosn $1) }

Boolean :: { AbsProgettoPar.Boolean Posn }
Boolean : 'true' { AbsProgettoPar.Boolean_true (tokenPosn $1) }
        | 'false' { AbsProgettoPar.Boolean_false (tokenPosn $1) }
        | 'True' { AbsProgettoPar.Boolean_True (tokenPosn $1) }
        | 'False' { AbsProgettoPar.Boolean_False (tokenPosn $1) }

S :: { AbsProgettoPar.S Posn }
S : STATEMENTS { AbsProgettoPar.StartCode $1 }

STATEMENTS :: { AbsProgettoPar.STATEMENTS Posn }
STATEMENTS : STATEMENT STATEMENTS { AbsProgettoPar.ListStatements $1 $2 }
           | {- empty -} { AbsProgettoPar.EmptyStatement }

B :: { AbsProgettoPar.B Posn }
B : '{' STATEMENTS '}' { AbsProgettoPar.BlockStatement $2 }

STATEMENT :: { AbsProgettoPar.STATEMENT Posn }
STATEMENT : B { AbsProgettoPar.Statement $1 }
          | EXPRESSIONSTATEMENT ';' { AbsProgettoPar.ExpressionStatement $1 }
          | LVALUEEXPRESSION ASSIGNOP EXPRESSION ';' { AbsProgettoPar.AssignmentStatement $1 $2 $3 }
          | CONDITIONALSTATE { AbsProgettoPar.ConditionalStatement $1 }
          | WHILESTATEMENT { AbsProgettoPar.WhileDoStatement $1 }
          | DOSTATEMENT { AbsProgettoPar.DoWhileStatement $1 }
          | FORSTATEMENT { AbsProgettoPar.ForStatement $1 }
          | 'break' ';' { AbsProgettoPar.BreakStatement }
          | 'continue' ';' { AbsProgettoPar.ContinueStatement }
          | RETURNSTATEMENT ';' { AbsProgettoPar.ReturnStatement  $1 }
          | VARIABLETYPE VARDECLIST ';' { AbsProgettoPar.VariableDeclarationStatement $1 $2 }
          | FORALLSTATEMENT { AbsProgettoPar.ForAllStatement $1 }
          | 'proc' Ident '(' PARAMETERS ')' ':' 'void' '{' STATEMENTS '}' { AbsProgettoPar.ProcedureStatement $2 $4 $9 }
          | 'function' Ident '(' PARAMETERS ')' ':' PRIMITIVETYPE '{' STATEMENTS '}' { AbsProgettoPar.FunctionStatement $2 $4 $7 $9 }

PARAMETERS :: { AbsProgettoPar.PARAMETERS Posn }
PARAMETERS : PARAMETER ',' PARAMETERS { AbsProgettoPar.ParameterList $1 $3 }
           | PARAMETER  { AbsProgettoPar.ParameterListSingle $1 }
           | {- empty -} { AbsProgettoPar.ParameterListEmpty }

PARAMETER :: { AbsProgettoPar.PARAMETER Posn }
PARAMETER : Ident ':' PRIMITIVETYPE { AbsProgettoPar.Parameter $1 $3 }

ASSIGNOP :: { AbsProgettoPar.ASSIGNOP Posn }
ASSIGNOP : '=' { AbsProgettoPar.AssignOperationEq }
         | '+=' { AbsProgettoPar.AssignOperationEqPlus }
         | '-=' { AbsProgettoPar.AssignOperationEqMinus }
         | '*=' { AbsProgettoPar.AssignOperationEqProd }
         | '/=' { AbsProgettoPar.AssignOperationEqFract }
         | '%=' { AbsProgettoPar.AssignOperationEqPercent }
         | '**=' { AbsProgettoPar.AssignOperationEqPower }

VARIABLETYPE :: { AbsProgettoPar.VARIABLETYPE Posn }
VARIABLETYPE : 'param' { AbsProgettoPar.VariableTypeParam }
             | 'const' { AbsProgettoPar.VariableTypeConst }
             | 'var' { AbsProgettoPar.VariableTypeVar }
             | 'ref' { AbsProgettoPar.VariableTypeRef }
             | 'const' 'ref' { AbsProgettoPar.VariableTypeConstRef }

VARDECLIST :: { AbsProgettoPar.VARDECLIST Posn }
VARDECLIST : VARDECID { AbsProgettoPar.VariableDeclarationSingle $1 }

VARDECID :: { AbsProgettoPar.VARDECID Posn }
VARDECID : IDENTLIST TYPEPART INITPART { AbsProgettoPar.VariableDeclaration $1 $2 $3 }

IDENTLIST :: { AbsProgettoPar.IDENTLIST Posn }
IDENTLIST : Ident ',' IDENTLIST { AbsProgettoPar.IdentifierList $1 $3 }
          | Ident { AbsProgettoPar.IdentifierSingle $1 }

TYPEPART :: { AbsProgettoPar.TYPEPART Posn }
TYPEPART : ':' TYPEEXPRESSION { AbsProgettoPar.TypePart $2 }

INITPART :: { AbsProgettoPar.INITPART Posn }
INITPART : '=' EXPRESSION { AbsProgettoPar.InitializzationPart $2 }
         | '=' '[' LISTELEMENTARRAY { AbsProgettoPar.InitializzationPartArray $3 }
         | {- empty -} { AbsProgettoPar.InitializzationPartEmpty }

LISTELEMENTARRAY :: { AbsProgettoPar.LISTELEMENTARRAY Posn }
LISTELEMENTARRAY : EXPRESSION ',' LISTELEMENTARRAY { AbsProgettoPar.ListElementsOfArray $1 $3 }
                 | EXPRESSION ']' { AbsProgettoPar.ListElementOfArray $1 }

TYPEEXPRESSION :: { AbsProgettoPar.TYPEEXPRESSION Posn }
TYPEEXPRESSION : PRIMITIVETYPE { AbsProgettoPar.TypeExpression $1 }
               | '[' RANGEEXP ']' PRIMITIVETYPE { AbsProgettoPar.TypeExpressionArraySimple $2 $4 }
               | '[' '{' RANGEEXP '}' ']' PRIMITIVETYPE { AbsProgettoPar.TypeExpressionArray $3 $6 }
               | PRIMITIVETYPE POINTER { AbsProgettoPar.TypeExpressionPointer $1 $2 }

POINTER :: { AbsProgettoPar.POINTER }
POINTER : POINTER '*' { AbsProgettoPar.PointerSymbol $1 }
        | '*' { AbsProgettoPar.PointerSymbolSingle }

RANGEEXP :: { AbsProgettoPar.RANGEEXP Posn }
RANGEEXP : EXPRESSION '..' EXPRESSION ',' RANGEEXP { AbsProgettoPar.RangeExpression $1 $3 $5 }
         | EXPRESSION '..' EXPRESSION { AbsProgettoPar.RangeExpressionSingle $1 $3 }

PRIMITIVETYPE :: { AbsProgettoPar.PRIMITIVETYPE Posn }
PRIMITIVETYPE : 'void' { AbsProgettoPar.PrimitiveTypeVoid }
              | 'bool' { AbsProgettoPar.PrimitiveTypeBool }
              | 'int' { AbsProgettoPar.PrimitiveTypeInt }
              | 'real' { AbsProgettoPar.PrimitiveTypeReal }
              | 'string' { AbsProgettoPar.PrimitiveTypeString }
              | 'char' { AbsProgettoPar.PrimitiveTypeChar }
              | '[' ']' PRIMITIVETYPE { AbsProgettoPar.TypeArray $3 }

CONDITIONALSTATE :: { AbsProgettoPar.CONDITIONALSTATE Posn }
CONDITIONALSTATE : 'if' EXPRESSION 'then' STATEMENT ELSESTATEMENT { AbsProgettoPar.ConditionalStatementSimpleThen $2 $4 $5 }
                 | 'if' EXPRESSION B ELSESTATEMENT { AbsProgettoPar.ConditionalStatementSimpleWThen $2 $3 $4 }
                 | 'if' CTRLDECSTATEMENT 'then' STATEMENT ELSESTATEMENT { AbsProgettoPar.ConditionalStatementCtrlThen $2 $4 $5 }
                 | 'if' CTRLDECSTATEMENT B ELSESTATEMENT { AbsProgettoPar.ConditionalStatementCtrlWThen $2 $3 $4 }

WHILESTATEMENT :: { AbsProgettoPar.WHILESTATEMENT Posn }
WHILESTATEMENT : 'while' EXPRESSION 'do' STATEMENT { AbsProgettoPar.WhileStateSimpleDo $2 $4 }
               | 'while' EXPRESSION B { AbsProgettoPar.WhileStateSimpleWDo $2 $3 }
               | 'while' CTRLDECSTATEMENT 'do' STATEMENT { AbsProgettoPar.WhileStateCtrlDo $2 $4 }
               | 'while' CTRLDECSTATEMENT B { AbsProgettoPar.WhileStateCtrlWDo $2 $3 }

DOSTATEMENT :: { AbsProgettoPar.DOSTATEMENT Posn }
DOSTATEMENT : 'do' STATEMENT 'while' EXPRESSION ';' { AbsProgettoPar.DoWhileState $2 $4 }

FORSTATEMENT :: { AbsProgettoPar.FORSTATEMENT Posn }
FORSTATEMENT : 'for' INDEXVARDEC 'in' EXPRESSION 'do' STATEMENT { AbsProgettoPar.ForStateIndexDo $2 $4 $6 }
             | 'for' INDEXVARDEC 'in' EXPRESSION B { AbsProgettoPar.ForStateIndexWDo $2 $4 $5 }
             | 'for' EXPRESSION 'do' STATEMENT { AbsProgettoPar.ForStateExprDo $2 $4 }
             | 'for' EXPRESSION B { AbsProgettoPar.ForStateExprWDo $2 $3 }

FORALLSTATEMENT :: { AbsProgettoPar.FORALLSTATEMENT Posn }
FORALLSTATEMENT : 'forall' INDEXVARDEC 'in' EXPRESSION 'do' STATEMENT { AbsProgettoPar.ForAllStateIndexDo $2 $4 $6 }
                | 'forall' INDEXVARDEC 'in' EXPRESSION B { AbsProgettoPar.ForAllStateIndexWDo $2 $4 $5 }
                | 'forall' EXPRESSION 'do' STATEMENT { AbsProgettoPar.ForAllStateExprDo $2 $4 }
                | 'forall' EXPRESSION B { AbsProgettoPar.ForAllStateExprWDo $2 $3 }

INDEXVARDEC :: { AbsProgettoPar.INDEXVARDEC Posn }
INDEXVARDEC : Ident { AbsProgettoPar.IndexVarDeclaration $1 }

ELSESTATEMENT :: { AbsProgettoPar.ELSESTATEMENT Posn }
ELSESTATEMENT : {- empty -} { AbsProgettoPar.ElseStateEmpty }
              | 'else' STATEMENT { AbsProgettoPar.ElseState $2 }

RETURNSTATEMENT :: { AbsProgettoPar.RETURNSTATEMENT Posn }
RETURNSTATEMENT : 'return' EXPRESSION { AbsProgettoPar.ReturnState $2 }
                | 'return' { AbsProgettoPar.ReturnStateEmpty }

CTRLDECSTATEMENT :: { AbsProgettoPar.CTRLDECSTATEMENT Posn }
CTRLDECSTATEMENT : 'var' Ident '=' EXPRESSION { AbsProgettoPar.CtrlDecStateVar $2 $4 }
                 | 'const' Ident '=' EXPRESSION { AbsProgettoPar.CtrlDecStateConst $2 $4 }

EXPRESSIONSTATEMENT :: { AbsProgettoPar.EXPRESSIONSTATEMENT Posn }
EXPRESSIONSTATEMENT : Ident { AbsProgettoPar.VariableExpression $1 }
                    | CALLEXPRESSION { AbsProgettoPar.CallExpression $1 }

CALLEXPRESSION :: { AbsProgettoPar.CALLEXPRESSION Posn }
CALLEXPRESSION : Ident '(' NAMEDEXPRESSIONLIST ')' { AbsProgettoPar.CallExpressionParentheses $1 $3 }
               | Ident '[' NAMEDEXPRESSIONLIST ']' { AbsProgettoPar.CallExpressionQuadre $1 $3 }

NAMEDEXPRESSIONLIST :: { AbsProgettoPar.NAMEDEXPRESSIONLIST Posn }
NAMEDEXPRESSIONLIST : NAMEDEXPRESSION { AbsProgettoPar.NamedExpressionList $1 }
                    | NAMEDEXPRESSION ',' NAMEDEXPRESSIONLIST { AbsProgettoPar.NamedExpressionLists $1 $3 }
                    | Ident '=' EXPRESSION { AbsProgettoPar.NamedExpressionAssigned $1 $3 }

NAMEDEXPRESSION :: { AbsProgettoPar.NAMEDEXPRESSION Posn }
NAMEDEXPRESSION : EXPRESSION { AbsProgettoPar.NamedExpression $1 }

EXPRESSION :: { AbsProgettoPar.EXPRESSION Posn }
EXPRESSION : Ident ARRAYINDEXELEMENT { AbsProgettoPar.ExpressionIdent $1 $2 }
           | Integer { AbsProgettoPar.ExpressionInteger $1 }
           | Double { AbsProgettoPar.ExpressionReal $1 }
           | String { AbsProgettoPar.ExpressionString $1 }
           | Char { AbsProgettoPar.ExpressionChar $1 }
           | Boolean { AbsProgettoPar.ExpressionBoolean $1 }
           | DEFAULT BINARYOP EXPRESSION { AbsProgettoPar.ExpressionBinary $1 $2 $3 }
           | UNARYOP EXPRESSION { AbsProgettoPar.ExpressionUnary $1 $2 }
           | DEFAULT ':' PRIMITIVETYPE { AbsProgettoPar.ExpressionCast $1 $3 }
           | '(' EXPRESSION ')' { AbsProgettoPar.ExpressionBracket $2 }

DEFAULT :: { AbsProgettoPar.DEFAULT Posn }
DEFAULT : Ident ARRAYINDEXELEMENT { AbsProgettoPar.ExpressionIdentD $1 $2 }
        | Integer { AbsProgettoPar.ExpressionIntegerD $1 }
        | Double { AbsProgettoPar.ExpressionRealD $1 }
        | String { AbsProgettoPar.ExpressionStringD $1 }
        | Char { AbsProgettoPar.ExpressionCharD $1 }
        | Boolean { AbsProgettoPar.ExpressionBooleanD $1 }
        | '(' EXPRESSION ')' { AbsProgettoPar.ExpressionBracketD $2 }

UNARYOP :: { AbsProgettoPar.UNARYOP Posn }
UNARYOP : '+' { AbsProgettoPar.UnaryOperationPositive }
        | '-' { AbsProgettoPar.UnaryOperationNegative }
        | '!' { AbsProgettoPar.UnaryOperationNot }
        | '&' { AbsProgettoPar.UnaryOperationPointer }

BINARYOP :: { AbsProgettoPar.BINARYOP Posn }
BINARYOP : '+' { AbsProgettoPar.BinaryOperationPlus }
         | '-' { AbsProgettoPar.BinaryOperationMinus }
         | '*' { AbsProgettoPar.BinaryOperationProduct }
         | '/' { AbsProgettoPar.BinaryOperationDivision }
         | '%' { AbsProgettoPar.BinaryOperationModule }
         | '**' { AbsProgettoPar.BinaryOperationPower }
         | '&&' { AbsProgettoPar.BinaryOperationAnd }
         | '||' { AbsProgettoPar.BinaryOperationOr }
         | '==' { AbsProgettoPar.BinaryOperationEq }
         | '!=' { AbsProgettoPar.BinaryOperationNotEq }
         | '>=' { AbsProgettoPar.BinaryOperationGratherEq }
         | '>' { AbsProgettoPar.BinaryOperationGrather }
         | '<=' { AbsProgettoPar.BinaryOperationLessEq }
         | '<' { AbsProgettoPar.BinaryOperationLess }

LVALUEEXPRESSION :: { AbsProgettoPar.LVALUEEXPRESSION Posn }
LVALUEEXPRESSION : Ident ARRAYINDEXELEMENT ',' LVALUEEXPRESSION { AbsProgettoPar.LvalueExpressions $1 $2 $4 }
                 | Ident ARRAYINDEXELEMENT { AbsProgettoPar.LvalueExpression $1 $2 }

ARRAYINDEXELEMENT :: { AbsProgettoPar.ARRAYINDEXELEMENT Posn }
ARRAYINDEXELEMENT : '[' TYPEINDEX ']' { AbsProgettoPar.ArrayIndexElement $2 }
                  | {- empty -} { AbsProgettoPar.ArrayIndexElementEmpty }

TYPEINDEX :: { AbsProgettoPar.TYPEINDEX Posn }
TYPEINDEX : TYPEINDEX ',' Integer { AbsProgettoPar.TypeOfIndexInt $1 $3 }
          | Integer { AbsProgettoPar.TypeOfIndexIntSingle $1 }
          | TYPEINDEX ',' Ident { AbsProgettoPar.TypeOfIndexVar $1 $3 }
          | Ident { AbsProgettoPar.TypeOfIndexVarSingle $1 }
{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

getTokenContent (PT _ (TV s)) = s
getTokenContent (PT _ (TI s)) = s
getTokenContent (PT _ (TC s)) = s
getTokenContent (PT _ (TL s)) = s
getTokenContent (PT _ (TD s)) = s

}

